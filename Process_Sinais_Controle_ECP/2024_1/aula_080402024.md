![Keppel-South-Central-Singapore.jpg](Keppel-South-Central-Singapore.jpg.webp)

<font size="1">[Keppel South Central, Singapura](https://www.cnnbrasil.com.br/lifestyle/10-projetos-de-design-e-arquitetura-que-prometem-moldar-o-mundo-em-2024/)</font>

# Projeto de Controladores (Digitais)

Aula de 08/04/2024.

>  **Observa√ß√µes iniciais**:
>  Doravante na nossa aulas vamos usar a ferramenta num√©rica (computacional) Matlab para realizar os c√°lculos e esbo√ßar os gr√°ficos necess√°rios. Mas al√©m disto, vamos aproveitar facilidades que o Matlab traz para cria√ß√£o de um "di√°rio" (arquivo texto) retratando os comandos usados numa se√ß√£o de trabalho no Matlab e vamos salvar o dados num arquivo de dados do Matlab para facilitar a continua√ß√£o de projetos de uma aula para a pr√≥xima.
>
>  üìÑ **Sugere-se fortemente** que o usu√°rio inicie os trabalhos no Matlab com o comando `diary('<nome_arquivo_texto>')` em cada aula (se√ß√£o de trabalho com o Matlab). Isto facilita a cria√ß√£o de um documento digital que reflete o que est√° sendo realizado em cada aula.
>
>  No caso deste registro em particular, avan√ßaremos um pouco mais, e vamos aplicar comandos no Matlab, j√° supondo a cria√ß√£o de um arquivo texto compat√≠vel com [**nota√ß√£o Markdown**](https://www.markdownguide.org). No entanto, estes comandos que s√≥ servem para editores compat√≠veis com Markdown (por exemplo, o [Harropad](http://pad.haroopress.com), [Typora](https://typora.io) ou Visual Estudio Code usando extens√µes como: [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one), [GitHub Markdown Preview](https://marketplace.visualstudio.com/items?itemName=bierner.github-markdown-preview), entre outros) ser√£o precedidos pelo caracter `%` que para o Matlab significa um coment√°rio (e assim evitamos mensagens de erro do Matlab tentando interpretar estes comandos). Para saber mais sobre como usaremos Markdown e o comando `diary()`nestas aulas, voc√™ pode consultar a p√°gina [Sugest√µes para uso do MATLAB nas aulas de Controle](https://fpassold.github.io/Controle_2/sugestao_uso_matlab_em_controle.html).
>
>  Este texto inclusive, foi iniciado aplicando-se o comando:
>
>  ```matlab
>  > diary aula_080402024.md
>  ```
>
> **Obs**.: S√≥ existe um leve inconveniente em gerar arquivo `.md` diretamente do Matlab. Por padr√£o o Matlab cria arquivos texto ASCII usando codifica√ß√£o ISO do Windows antigo para os caracteres com acentua√ß√£o e n√£o o novo formato UTF-8 adotado pelos modernos editores Markdown. O que significa que antes de editar o arquivo gerado pelo Matlab num editor Markdown, seja bastante interessante mudar a codifica√ß√£o dos caracteres para o formato **UTF-8**.

Iniciando ent√£o os trabalhos... [:musical_note:](https://youtu.be/VImDFJyIrr4?si=O-bnNk3w1880RXQQ).

## Ingressando a planta

Suponha um sistema mec√¢nico (ou "planta") caracterizado pela equa√ß√£o:

$G(s)=\dfrac{16}{(s+1)(s+2)(s+8)}$

Vamos amostrar este sistema usando per√≠odo de amostragem de $T=0,1$ segundos.

Nossa malha fica algo como:

<img src="https://fpassold.github.io/Controle_3/estudo_caso/blocos_com_controlador2.png" alt="malha-controle" style="zoom:50%;" />

Devemos considerar o sustentador de ordem zero presente numa malha de controle digital e calcular o $BoG(z)$:

$BoG(z)=(1-z^{-1}) \mathbb{Z} \left\{ \dfrac{G(s)}{s}\right\}$

ou podemos usar a fun√ß√£o `c2d()` do Matlab para realizar este c√°lculo:

```matlab
>> T = 0.1;
>> BoG = c2d(G, T)

BoG =

  0.002045 z^2 + 0.006274 z + 0.00118
  -----------------------------------
  z^3 - 2.173 z^2 + 1.515 z - 0.3329

Sample time: 0.1 seconds
Discrete-time transfer function.

>> zpk(BoG)         % apresenta a fun√ß√£o BoG(z) num formato mais "amig√°vel"

ans =

   0.0020446 (z+2.867) (z+0.2013)
  --------------------------------
  (z-0.9048) (z-0.8187) (z-0.4493)

Sample time: 0.1 seconds
Discrete-time zero/pole/gain model.
```

Podemos aproveitar para tra√ßar um diagrama de p√≥lo-zero no plano-z:

```Matlab
>> pzmap(BoG)
>> axis equal       % para o c√≠rculo unit√°rio no plano-z parecer um c√≠rculo
```

O resultado por ser visto abaixo:

<img src="rl_BoG.png" alt="rl_BoG" style="zoom:50%;" />

Vamos usar esta planta (sistema) para realizar projetos de diferentes controladores.



## Controlador Proporcional - Projeto 1

Nosso primeiro controlador √© um simples controlador proporcional. Ou seja, simplesmente vamos fechar uma malha para o sistema anterior, apenas com um ganho. Inicialmente, vamos considerar que este ganho seja unit√°rio, $K=1$.

Para simular este sistema em malha-fechada temos que determinar a fun√ß√£o transfer√™ncia da malha-fechada, dada pela equa√ß√£o:

$FTMF(z)=\dfrac{C(z)\cdot BoG(z)}{1 + H(z) \cdot C(z) \cdot BoG(z)}$

onde: $C(z)=$ equa√ß√£o (fun√ß√£o transfer√™ncia do controlador (neste caso, $C(z)=K$); 
$BoG(z)=$ vers√£o "digitalizada" da planta considerando um sustentador de ordem-zero, e; 
$H(z)=$ fun√ß√£o transfer√™ncia do sensor usado para fechar a malha de controle.

>  Note que alguns sistemas de controle, quando modelados, incorporam a fun√ß√£o transfer√™ncia do sensor ou bloco de comunica√ß√£o usado para medir a sa√≠da da planta e comunicar os dados. Esta fun√ß√£o transfer√™ncia, normalmente √© chamada de $H(s)$. Na pr√°tica, quando usada, se assemelha √† um filtro passa-baixas onde a frequ√™ncia de corte corresponde √† "banda passante" do sensor e eventualmente ainda incorpora um atraso no tempo (termo $e^{-\Delta\,t\cdot s}$) se for considerado algum atraso n√£o desprez√≠vel na comunica√ß√£o do sinal do sensor para a malha de controle (caso de sistemas de comunica√ß√£o, sistemas com lat√™ncia elevada). 
>
>  Normalmente se considera $H(s)=1$ o que significa que estamos negligenciando limita√ß√µes de banda passante do sensor ou atrasos de comunica√ß√£o. Normalmente se adota um sensor r√°pido o suficiente para controle do sistema e se existe atraso de comunica√ß√£o ele √© desprez√≠vel (m√≠nimo) em rela√ß√£o aos tempos de resposta da planta (do sistema que se quer controlar).
>
>  Quando $H(z)=1$, estamos lidando com um sistema de **realimenta√ß√£o unit√°ria**, e ent√£o:
>
>  $FTMF(z)=\dfrac{FTMA(z)}{1+FTMA(z)}$
>
>  onde: $FTMA(z) = $ equa√ß√£o de malha-direta do sistema (ou fun√ß√£o transfer√™ncia de malha aberta para sistemas com realimenta√ß√£o unit√°ria).

O Matlab permite determinar a $FTMF(z)$ usando a fun√ß√£o `feedback()` cuja sintaxe ou uso seria:

```Matlab
>> <tf-MF> = feedback(<tf-MA>, <tf-H>, <sinal-realimenta√ß√£o>)
```

onde: `tf=MF =` fun√ß√£o transf√™ncia resultante do c√°lculo, a $FTMF(z)$; 
`tf-MA =` transfer function da equa√ß√£o de malha-direta, ou $FTMA(z) = C(z) \cdot BoG(z)$; 
`tf-H = ` transfer fucntion do sensor (ou canal de comunica√ß√£o), no nosso caso, de realimenta√ß√£o unit√°ria, $H(z)=1$; e,
`sinal-realimenta√ß√£o = ` sinal correspondente correspondente √† realimenta√ß√£o adotada, no caso, um n√∫mero: $1$ ou $-1$ que indica realimenta√ß√£o positiva (incomum) ou negativa respectivamente. Na maior parte dos casos, a realimenta√ß√£o √© sempre negativa, ent√£o este terceito par√¢metro seria $=-1$, mas o pr√≥prio Matlab j√° assume que normalmente a realimenta√ß√£o seja negativa, ent√£o o ingresso do 3o-par√¢metro n√£o √© necess√°rio (e neste caso, o Matlab interpreta que a realimenta√ß√£o seja negativa).

Voltando ao nosso caso:

```matlab
>> K=1;         % deixando claro que o ganho do controlador √© unit√°rio (estamos testando)
>> % fechando a malha...
>> ftmf = feedback(K*BoG, 1)    

ftmf =
 
  0.002045 z^2 + 0.006274 z + 0.00118
  -----------------------------------
  z^3 - 2.171 z^2 + 1.522 z - 0.3317
 
Sample time: 0.1 seconds
Discrete-time transfer function.
```

Note que esta equa√ß√£o em si n√£o √© importante. Mas pode nos interessar os **p√≥los de malha-fechada** do sistema. Eles nos permitem concluir se o sistema em MF ficou est√°vel (todos os p√≥los de MF dentro do c√≠rculo unit√°rio) ou inst√°vel (algum p√≥lo de MF fora do c√≠rculo unit√°rio)

Podemos separar os p√≥los de MF de um sistema de controle no Matlab usando a fun√ß√£o `pole()`:

```matlab
>> pole(ftmf)       % mostra os p√≥los da FTMF(z)
ans =
      0.87205 +     0.1295i
      0.87205 -     0.1295i
      0.42676 +          0i
```

### Gr√°fico do *Root-Locus*

üëâ Mas, mais interessante que isto, √© plotar um gr√°fico que mostra **como os p√≥los de MF "caminham" no plano-z** se o usu√°rio variasse o ganho de malha-fechada. Neste caso, como os p√≥los de MF caminhariam se o ganho do controlador fosse variado de um valor muito pr√≥ximo de zero at√© um valor bem elevado ($0 < K < \infty$). Poder√≠amos fazer isto, realizando o c√°lculo de MF anterior para valores crescentes de $K$ e pedindo para o Matlab plotar o "caminho" formado pelas diferentes possi√ß√µes que seriam assumidas pelos p√≥los de MF. Este procedimento √© conhecido como **diagrama do lugar geom√©trico das ra√≠zes**, ou mais simplesmente ***root-locus***. Para nossa sorte, o Matlab automatiza estes c√°lculos e j√° apresenta o resultado na forma de um gr√°fico no plano-z usando-se a fun√ß√£o `rlocus()`:

```matlab
>> figure; rlocus(BoG)
```

Deve ter sido gerada uma figura como:

<img src="rl_Prop.png" alt="rl_Prop.png" style="zoom:50%;" />

Podemos realizar um "zoom" manual sobre a figura ou amplificar a zona de observa√ß√£o no gr√°fico usando o comando `axis`:

```matlab
>> axis([-0.6 1.2 -0.5 1.2])
```

O "zoom" anterior concentrou a observa√ß√£o do *root-locus* (ou simplemente RL) sobre uma certa regi√£o:

<img src="rl_Prop_zoom.png" alt="rl_Prop_zoom.png" style="zoom:50%;" />

Note que, clicando com o bot√£o direito do mouse sobre pontos da curva, podemos incluir os "**data-tips**" ("bal√µes") que  aparecem na figura anterior mostrando informa√ß√µes relevantes sobre o ponto selecionado.

>  Matematicamente √© poss√≠vel provar que todos os p√≥los de malha-aberta, √† medida que o ganho de malha-fechada aumenta, "caminham" para os zeros de malha-aberta da $FTMA(z)$. O que "caminha" s√£o os p√≥los de malha-fechada, e sua posi√ß√£o depende do ganho adotado -- como ser reparado nos *data-tips* mostrados na figura anterior. Repare na figura anterior, que quando se usa um ganho muito baixo, o p√≥lo de MF est√° pr√≥ximo do p√≥lo de MA (ponto de partida dos tra√ßados num RL). **Qualquer tra√ßado no RL parte sempre dos p√≥los de MA da $FTMA(z)$ de um sistema**. A medida que o ganho aumenta, repare o p√≥lo de MF "caminha". Para tra√ßado manual do RL (sim, isto √© poss√≠vel, usando-se certas regras), parte-se sempre do p√≥lo de MA localizado no lado mais extremo √† direita no plano-z e se realiza um tra√ßado na dire√ß√£o de $z=-\infty$. Eventualmente nesta trajet√≥ria, um p√≥lo de MF encontra outro p√≥lo de MF e ent√£o se produz um "choque", caracterizando um **ponto de partida**, ou ***break-out*** no *root-locus* e neste caso, os p√≥los de MF "sobem" e "descem" no plano-z, isto √©, assumem n√∫meros complexos (sempre foram n√∫meros complexos) com parte imagin√°ria n√£o nula. Em alguns casos, estes p√≥los continuam sua trajet√≥ria descrevendo retas que apenas "sobem" ou "descem" (a parte imagin√°ria do n√∫mere assume valores cada vez maiores). Em outros casos, como este, os p√≥los de MF, descrevem uma esp√©cie de c√≠rculo no plano-z e √† partir de certo valor (elevado) de ganho, eles voltam a assumir apenas valores reais (a parte imagin√°ria volta √† ser nula -- este ponto √© chamado de **ponto de chegada** ou de ***break-in***) e neste caso, um dos p√≥los de MF seguiu na dire√ß√£o de $z \to -\infty$ e o outro p√≥lo de MF foi na dire√ß√£o do zero de MA localizado em $s=-2,867$.
>   
>   Note ainda que existe **um tra√ßado no RL para cada p√≥lo do sistema**. No caso, note que s√£o 3 curvas (a $FTMA(z)$ neste caso possui 3 p√≥los). Repare que o p√≥lo de MA mais "interno", localizado em $z=-0.4493$ caminhou na dire√ß√£o do zero de MA localizado em $z=-0.2013$ (linha vermelha).

No nossso caso, vamos contar com a fun√ß√£o `rlocus()` do Matlab para nos ajudar a tra√ßar o *root-locus* de um sistema em MF. 

Na realidade, vamos usar esta **ferramenta de projeto** para controladores digitais. Neste caso, esta t√©cnica de projeto seria chamada: **projeto usando lugar geom√©trico das ra√≠zes** ou mais simplesmente **projeto usando *root-locus***.

Apesar do `rlocus()`  poder antecipar como o sistema vai se comportar no tempo discreto ($kT$), o `rlocus()` sozinho n√£o mostra como o sistema responde para determinado valor de ganho.

Se quisermos saber como o sistema responde para uma refer√™ncia (sinal de "*set-point*") que √© uma "**entrada degrau**, ou seja, que corresponde √† uma constante de amplitude qualquer, que varia do valor zero at√© o valor desejado instantaneamente, temos que fechar a malha do sistema (calcular a $FTMF(z)$), considerando esta esta refer√™ncia (sua transformada-z: $R(z)$), para calcular a sa√≠da deste sistema, primeiro no plano-z: $Y(z)$ e ent√£o realizar a transformada-z inversa sobre $Y(z)$ para finalmente obter a resposta no tempo discreto: $y[kT]$. Ou seja, realizar algo como:

$\begin{array}{rcl} Y(z) & = & \underbrace{R(z)}_{\text{Degrau}} \cdot FTMF(z)\\ & \downarrow & \mathbb{Z}^{-1}\\ y[kT] & = & y[0]z^0 + y[1]z^{-1} + y[2]z^{-2} + \ldots + y[\infty]z^{\infty}\end{array}$

E claro, necessitamos "graficar" esta resposta.

O Matlab facilita estes c√°clulos usando-se a fun√ß√£o `step()`:

```matlab
>> % Resposta temporal para entrada degrau unit√°rio e para K=1
>> figure; step(ftmf)
```

A resposta do sistema de MF para uma entrada degrau unit√°rio pode ser vista no gr√°fico √† seguir:

<img src="step_Prop.png" alt="step_Prop.png" style="zoom:50%;" />

Percebe-se um tipo de **resposta sub-amortecida** (com algum *overshoot* ou sobre-sinal), t√≠pica de sistema com p√≥los complexos em MF. Se for caso, revise o item [Respostas temporais t√≠picas de Processos Industriais](https://fpassold.github.io/Process_Sinais_Controle_ECP/4_Respostas_Sistemas.pdf).

### Determina√ß√£o de $K_{max}$

**Mas o que acontece se usamos um ganho muito elevado num sistema?**

O gr√°fico anterior, mostrou a resposta temporal de um sitema em MF para entrada degrau unit√°rio quando o ganho do controlador foi unit√°rio, $K=1$. 

Mas e se este ganho fosse maior? E aqui come√ßa a entrar a utilidade do diagrama de *root-locus*. 

> Pela teoria j√° vista sobre transoformada-z e resposta de sistemas lineares no tempo, sabemos que se por acaso, um p√≥lo de MF cruzar o circuito unit√°rio, que o sistmea fica inst√°vel (sua amplitude, resposta de sa√≠da, s√≥ aumenta). O limite para esta situa√ß√£o √© quando algum p√≥lo de MF se localiza exatamente sobre o c√≠rculo unit√°rio, com seu m√≥dulo valendo exatamente 1 (podemos interpretar graficamente isto como um raio de comprimento unit√°rio). Note que este p√≥lo pode ser real ou complexo. E basta apenas 1 p√≥lo de MF com m√≥dulo $>1$ para que o sistema se torne inst√°vel. Se um par de p√≥los complexos (conjugados) se localizar exatamente sobre o c√≠rculo unit√°rio teremos uma **resposta oscilat√≥ria no limite da estabilidade**, uma sen√≥ide com certa defasagem e frequ√™nica de oscila√ß√£o, valor m√©dio n√£o-nulo, mas com amplitude "sustentada", ou seja, que n√£o aumenta nem diminui, mesmo passando muito tempo de opera√ß√£o (ou simula√ß√£o). Obviamente n√£o √© desej√°vel manter esta condi√ß√£o (este valor de ganho num sistema de MF) por muito tempo, mas esta oscila√ß√£o (frequ√™ncia e ganho) pode ser √∫til para sintonizar controladores.

No nosso caso, podemos revisitar o gr√°fico do *root-locus* e tentar descobrir o valor limite de ganho, chamado de **ganho m√°ximo** ($K_{max}$) ou ***ultimate gain*** ($K_u$).

Testando o ganho m√°ximo aplic√°cel num sistema:

<img src="rl_Prop_Kmax.png" alt="rl_Prop_Kmax.png" style="zoom:50%;" />

Parece resultar num $K_{max} \approx 10,6$. Fechando a malha com este valor para comprovar a resposta:

```matlab
>> K_max = 10.6;
>> ftmf_Kmax = feedback(K_max*BoG, 1);
>> figure; step(ftmf_Kmax)
```

Deve ter sido obtido o gr√°fico abaixo:

<img src="step_K_max.png" alt="step_K_max.png" style="zoom:50%;" />

Notamos que este valor de $K$ ainda n√£o corresponde ao ganho m√°ximo. Vamos aument√°-lo um pouco:

```matlab
>> K_max = 12;
>> ftmf_Kmax = feedback(K_max*BoG, 1);
>> figure; step(ftmf_Kmax)
```

O que deve ter resultado no seguinte gr√°fico:

<img src="step_K_max2.png" alt="step_K_max2.png" style="zoom:50%;" />

Notamos ent√£o que: $10,6 < K_{max} < 12$. O valor exato pode ser calculdo se for usado o **M√©todo de Juri** associado com determina√ß√£o de estabilidade de sistemas no plano-z. Mas este m√©todo est√° fora do escopo desta disciplina. Ele pode ser visto no [v√≠deo](https://www.youtube.com/watch?v=90jHX8YVWhQ) do Prof. Luiz Ant√¥nio Aguirre da UFMG (13 minutos).

### Calculando erro de regime permanente

Voltando ao nosso caso, mesmo que um ganho seja fixado para determinado controlador, n√£o significa que o sistema responda da forma desejada e sem erro. Neste caso, o erro de regime permanente pode ser elevado. 

Neste caso em particular, nossa planta √© um sistema tipo 0 (sem integrador) e a entrada (refer√™ncia) √© do tipo Degrau, o que implica que a malha-fechada do mesmo sempre vai resultar em algum erro. 

<img src="https://fpassold.github.io/Controle_3/4_teoria_erros/erro_degrau_sistema0.png" alt="erro" style="zoom:40%;" />

Este erro s√≥ poder√° ser anulado com acr√©scimo da a√ß√£o integral. Rever [Teoria do Erro](https://fpassold.github.io/Controle_3/4_teoria_erros/resumo_teoria_erro.html) se for o caso.

Repare no primeiro gr√°fico de resposta √† entrada degrau, que a refer√™ncia, *set-point*, valor final desejado para o sistema era $r[\infty]=1$ e repare que o sistema estabilizou em $y[\infty] = 0,5$. O que significa um erro enorme de 50%. Lembre que:

$E(z)=R(z)-Y(z)$

ou:

$e[\infty]=r[\infty] - y[\infty]$

Podemos usar o Matlab para calcular este erro.

Calculando o erro de MF para o caso de $K=1$:

```matlab
>> dcgain(ftmf)         % permite descobrir y[‚àû]
ans =
          0.5
>> erro = ((1-dcgain(ftmf))/1)*100
erro =
           50
```

> **Nota sobre a fun√ß√£o `dcgain()` do Matlab**:
>
> Note que na realidade a fun√ß√£o `dcgain(<tf>)` do Matlab realiza o seguinte c√°lculo, para o caso da transfer funcion, `<tf>`, passada como argumento de entrada estiver no plano-z:
> 
> $\text{dcgain(F)} = \displaystyle\lim_{z \to 1} \cancel{(z-1)} \cdot \underbrace{\dfrac{z}{\cancel{(z-1)}}}_{Degrau} \cdot F(z) = 1 \cdot \lim_{z \to 1} F(z)$
> 
> ou seja, descobre o valor final, em $kT \to \infty$ do sistema representado pela `tf` quando aplicada uma entrada degrau no mesmo.
>
> Ent√£o, neste caso, calcular `dcgain(ftmf)` termina por determinar a sa√≠da final do sistema no tempo discreto ($kT$) quando o mesmo √© submetido a uma entrada degrau, justamente o que foi feito neste teste (usamos como refer√™ncia, uma "entrada degrau").




## Controlador Proporcional - Projeto 2

A ideia agora √© determinar que valor de ganho deveria ser adotado em fun√ß√£o do **erro m√°ximo tolerado** (ou especificado) para o sistema (em malha-fechada). Isto √© chamado de "**requisito de controle**". Neste caso:

* $e(\infty)=20\%$

Podemos prever (determinar) este erro lembrando da [Teoria do erro](https://fpassold.github.io/Controle_3/4_teoria_erros/resumo_teoria_erro.html).

Neste caso, √© usada uma entrada degrau como refer√™ncia e a planta √© um sistema do tipo 0 (sem integrador), ent√£o:

$e_{step}=\dfrac{1}{1+K_p}$		(eq. (1))

onde: 

$K_p = \displaystyle\lim_{z \to 1} FTMA(z)$

> $K_p = $ constante (do erro est√°tico) de posi√ß√£o.

Neste caso √© desejado: $e(\infty)=20\%=0.2$ (para degrau unit√°rio, $r[\infty]=1,0$). Considerando este valor na eq. (1):

$0,2 = \dfrac{1}{1+K_p}$

$0,2(1+K_p)=1$

isolando $K_p$ obtemos:

$K_p=\dfrac{1-0,2}{0,2}$

Usando Matlab para determinar o valor desejado para $K_p$:

```Matlab
>> Kp=(1-0.2)/0.2
Kp =
     4
```

Agora nos falta calcular o $K_p$ deste sistema:

$K_p = \displaystyle\lim_{z \to 1} FTMA(z) = \displaystyle\lim_{z \to 1} K \cdot BoG(z) = K \cdot \displaystyle\lim_{z \to 1} BoG(z)$

podemos usar a fun√ß√£o `dcgain()` para calcular $\displaystyle\lim_{z \to 1} BoG(z)$:

```Matlab
>> dcgain(BoG)
ans =
            1
```

ou podemos fazer isto manualmente:

$BoG(z) = \dfrac{0,0020446 (z+2,867) (z+0,2013)}{(z-0.9048) (z-0.8187) (z-0.4493)}$

$\displaystyle\lim_{z \to 1} BoG(z) = \dfrac{0,0020446 (1+2,867) (1+0,2013)}{(1-0.9048) (1-0.8187) (1-0.4493)} = \dfrac{0,009498}{0.0095049} = 0,99927 \approx 1,0$

Usando Matlab:

```matlab
>> numerador = 0.0020446*(1+2.867)*(1+0.2013)
numerador =
     0.009498
>> denominador = (1-0.9048)*(1-0.8187)*(1-0.4493)
denominador =
    0.0095049
>> numerador/denominador
ans =
      0.99927
```

Mas se estamos usando o Matlab e temos acesso a *transfer function* de $BoG(z)$, este c√°lculo pode ser feito com muito mais precis√£o, lembrando que uma *transfer-funciton* √© formada por um polin√¥mio (vetor para o Matlab) no seu numerador e outro polin√¥mio (vetor para o Matlab) no seu denominador e ent√£o podemos usar a fun√ß√£o `polyval()` para substituir determinado valor dentro de um polin√¥mio e assim determinar o valor final, ou:

```matlab
>> [num,den]=tfdata(BoG,'v')	% permite extrair o N(z) e D(z) de uma transfer-function
num =
            0    0.0020446    0.0062741    0.0011804
den =
            1      -2.1729       1.5153     -0.33287
```

> A fun√ß√£o `tfdata()` permite extrair dados desejados de um objeto *transfer-function* no Matlab.
> Neste caso, desejamos "extrair" o polin√µmio do numerador, $N(z)$ e do denominador, $D(z)$ que comp√µe a *transfer-function* associada com o $BoG(z), ou:
>
> $BoG(z)=\dfrac{N(z)}{D(z)}$. 
>
> Para tanto, al√©m de passar como primeiro argumento de entrada a ¬¥pr√≥pria fun√ß√£o transfer√™ncia, se passa como segundo argumento de entrada, a *string* `-v`, que significa *-verbouse*.

Note que no resultado anterior:

```
num =       z^3  z^2          z^1          zÀÜ0
            0    0.0020446    0.0062741    0.0011804

den =       z^3    z^2           z^1        zÀÜ0
            1      -2.1729       1.5153     -0.33287
```

compare com:

```matlab
>> BoG

BoG =
 
  0.002045 z^2 + 0.006274 z + 0.00118
  -----------------------------------
  z^3 - 2.173 z^2 + 1.515 z - 0.3329
 
Sample time: 0.1 seconds
Discrete-time transfer function.
```

ent√£o agora necessitamos substituir no lugar de $z$ o valor $1$, usando a fun√ß√£o `polyval()`:

```matlab
>> numerador = polyval(num, 1)
numerador =
    0.0094991
>> denominador = polyval(den, 1)
denominador =
    0.0094991
>> numerador/denominador
ans =
            1
```

ou seja, $\displaystyle\lim_{z \to 1} BoG(z) = 1$

Voltando √† determina√ß√£o do ganho $K$, necess√°rio para manter o o erro dentro de determinado valor, temos ent√£o:

$K_p = K \cdot \underbrace{\displaystyle\lim_{z \to 1} BoG(z)}_{\text{>> dcgain(BoG)}} = K \cdot 1$

como $K_p$ desejado √© igual √† 4, ent√£o:

$K = 4$

este deveria ser o valor do ganho proporcional √† ser usado neste sitema para garantir o erro de regime permanente limitado aos 20% desejados.

Fechando a malha com $K=4$ e verificando o $e(\infty)$:

```matlab
>> K=4;
>> ftmf_K4 = feedback(K*BoG, 1);
>> figure; step(ftmf_K4)
```

E ent√£o obtemos o seguinte resultado para a entrada degrau unit√°rio:

<img src="step_K4.png" alt="step_K4.png" style="zoom:50%;" />

Podemos usar a fun√ß√£o `stepinfo()` do Matlab para nos mostrar a caracter√≠sticas de resposta ressaltadas no gr√°fico na forma de bal√µes:

```matlab
>> stepinfo(ftmf_K4)

        RiseTime: 0.5
    SettlingTime: 5
     SettlingMin: 0.66163
     SettlingMax: 1.1238
       Overshoot: 40.48
      Undershoot: 0
            Peak: 1.1238
        PeakTime: 1.2

>> % Calculando o erro:
>> erro = ((1-dcgain(ftmf_K4))/1)*100
erro =
           20
```



## Controlador Proporcional - Projeto 3

Neste caso, o usu√°rio (cliente) especifica um **valor m√°ximo toler√°vel de *overshoot* (sobre-sinal)**.

Vamos supor que seja: $\%OS \le 10\%$.

Lembrando da teoria associada com [Respostas temporais de sistemas](https://fpassold.github.io/Process_Sinais_Controle_ECP/4_Respostas_Sistemas.pdf).


Notamos que existe uma forma de determinar o valor da constante de amortecimento $\zeta$ para sistemas de 2a-ordem em MF, se conhecemos o valor de $\%OS$ (percentual de *overshoot*):

$\zeta=\dfrac{-\ln(\%OS/100)}{ \sqrt{\pi^2+\ln(\%OS/100)^2 } }$

O interessante √© que uma "**linha guia**" no plano-z (ou seja no diagrama de *root-locus*) pode ser tra√ßada no RL). Esta linha-guia representa **p√≥los de MF de 2a-ordem que resultam num mesmo valor de $\%OS$ ou de $\zeta$**. Para tra√ßar esta linha guia, usamos a fun√ß√£o ¬¥zgrid()` no Matlab.

Usando o Matlab:

```matlab
>> OS=10; 		% Overshoot m√°ximo tolerado
>> zeta=(-log(OS/100))/(sqrt(pi^2+(log(OS/100)^2))) 	% calculado o correspondente zeta
zeta =
      0.59116
>> figure; rlocus(BoG)
>> hold on; zgrid(zeta, 0)
>> axis([-1 1 -1 1])            % para concentrar o gr√°fico do RL na regi√£o desejada
>> [K_OS,polosMF] = rlocfind(BoG)
Select a point in the graphics window
selected_point =
      0.86967 +    0.14241i
K_OS =
        1.192
polosMF =
       0.8737 +    0.14191i
       0.8737 -    0.14191i
      0.42306 +          0i
```

O RL ressaltando o ponto desejado aparece na pr√≥xima figura:

<img src="rl_K_OS.png" alt="rl_K_OS.png" style="zoom:50%;" />

*Falta terminar... aula atingiu seu final em 08/04/2024. Continua√ß√£o na pr√≥xima aula...*

---

### Encerrando uma se√ß√£o de trabalho no Matlab

N√£o esquecer de aplicar os comandos a seguir para salvar os dados necess√°rios para continuar este projeto na pr√≥xima aula:

```matlab
>> save planta      % salva os dados (vari√°veis do workspace) no arquivo planta.mat
>> diary off        % fecha o arquivo texto di√°rio criado nesta se√ß√£o de trabalho
>> quit				% fecha o Matlab
```

Fim.

---

Prof. Fernando Passold, em 11/04/2024.

