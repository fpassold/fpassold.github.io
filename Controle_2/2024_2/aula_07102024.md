# Projeto de Controladores usando RL

Continua√ß√£o da [aula de 30/09/2024](aula_30092024.html). Esta terminou com projeto de controladores PD baseado em esbo√ßos no RL.

A id√©ia √© usar uma ferramenta mais moderna e "contundente" para realizar projeto de controladores deste tipo (ou outros), no caso o ***App Control System Designer*** que acompanha o ***Toolbox Control Systems***.

[üéµ](https://youtu.be/6WwNQZY8qD0?si=KqR6yhfS8sRY5UNQ)

## Projeto de PD usando App Control System Designer

Recuperando dados aula passada:

```matlab
>> load planta
>> zpk(G)   % se lembrando da planta

          20
  ------------------
  (s+10) (s+4) (s+1)
 
Continuous-time zero/pole/gain model.
```

Ativando o ***App Control System Designer*** no Matlab:

![App_Control_System_Designer_1.png](App_Control_System_Designer_1.png)

Depois de ativar este App, ser√° necess√°rio:

1. **Confirmar arquitetura do sistema de controle**, ingressando em "Edit Architecure" (1) e selecionando a primeira op√ß√£o, referente a um sistema "cl√°ssico" de controle em MF:

    ![Control_System_Designer_Architecture](Control_System_Designer_Architecture.png)

2. Na parte inferior desta janela (de "Edit Architecture"), se faz necess√°rio **carregar a *tf* da planta √† se controlada**, var√≠avel `G` no nosso caso. Para tanto, clicar no bot√£o ao lado do bloco "G". Uma nova janela se abre permitindo selecionar alguma *tf* (*transfer function*) j√° presente no ambiente de trabalho do Matlab. Por isto foi importante antes de ativar este App, carregar os dados da aula passada. Note que apenas *tf*¬¥s s√£o listadas. Neste caso coincide que √© a vari√°vel `G`. Nesta janela em que foi selecionada a *tf* para o bloco "G", clicar em `importar`. 

   ![Import_Data_Edit_Architecture_Control_System_Designer-3](Import_Data_Edit_Architecture_Control_System_Designer-3.png)

   O Matlab deve voltar para a janela inicial de "Edit Architecture". Nesta janela cliclar agora no bot√£o `OK`. Note que se tudo foi feito da forma correta, os gr√°ficos da tela principal do "Control System Desinger" foram atualizadas (como esperado). Deve estar aparecer o resutlado do fechamento da malha usando apenas ganho (proporcional), unit√°rio: note que o gr[afico do RL (√† esquerda) e o gr√°fico do "step" (a direita) devem ter sido atualizados refletindo o comportamento desta planta para este controlador.

> Na CLI do Matlab voc√™ pode listar todas as vari√°veis j√° criadas usando o comando `who`.

3. Antes de prosseguir, vamos **personalizar os gr√°ficos sendo exibidos** por *default* por este App. Como estamos realizando projeto usando como ferrramenta RL, podemos simplesmente fechar a janela do Diagrama de Bode que normalmente aparece grande no canto esquerdo. Deve restar a janela do RL e da resposta ao degrau (*step*) no lado direito. Clique com o mouse (e mantenha pressionado) a barra de t√≠tulo da janela do RL e "arraste-a" para o lado esquerdo no lugar do espa√ßo que antes era ocupado pelo Diagrama de Bode". Aproveite para arrastar a janela (menor) do *step* para o canto superior direito. 
4. Sugere-se ainda que o canto inferior direito, desocupado neste momento, seja preenchido com um **novo gr√°fico retratanto o *esfor√ßo de controle*** (ou var√≠avel $u(t)$). Para tanto, selecione esta parte vazia e depois pressione o bot√£o "New Plot" (barra superior do App). Uma esp√©cie de menu *pull-down* gr√°fico deve sugir permitindo escolher outra informa√ß√£o gr√°fica. Neste caso, nos interessa (selecionar): "New Step". Outra janela se abre permitindo "personalizar" o que deve ser mostrado neste gr√°fico. Algumas op√ß√µes aparecem juntamente com um diagrama de blocos para ajudar a descobrir a op√ß√£o desejada. Neste caso, queremos um gr√°fico do tipo $r(t) \times u(t)$, ou "IOTransfer_r2u", algo como:

<img src="New_Step_Control_System_Designer-IOTransfer_r2u__step.png" alt="New_Step_Control_System_Designer-IOTransfer_r2u__step.png" style="zoom:87%;" />

   Isto far√° como que na parte inferior direita o App atualize o gr√°fico do sinal de controle, $u(t)$ para a refer√™ncia (entrada degrau) usada como *set-point* do sistema.

4. E um **√∫ltimo ajuste** ainda, antes de iniciar realmente os trabalhos neste App. Se recomenda alterar "**Preferences**". Clique neste bot√£o na aba superior. Na nova janela que se abre aparecem umas 5 abas/bot√µes na parte superior. Selecionar a aba "Option" e mudar "Compensatpr Format" para "[x] Zero/pole/gain", isto far√° o App exibir a *tf* do controlador num formato mais "agrad√°vel" para quem est√° projeto usando RL:

    $C(s)=K\left( \dfrac{s+z}{s+p} \right)$

    ![Control_System_Designer_Preferences](Control_System_Designer_Preferences.png)

5. Daqui para frente voc√™ pode prosseguir com o projeto de seu controlador.

6. **Outros ajustes interessantes**:

    * Informar **Requerimentos de projeto no RL** do App:

      ![Control_System_Designer-Design_Requirements](Control_System_Designer-Design_Requirements.png)

      Neste caso, foram informados:

      * Percent overshoot < 10,0 % (faz surgir a linha "*sgrid*").
      * Settling time < 0,7 segundos (faz surgir a reta paralela ao eixo $j\omega$, $\propto t_s$)
      * A regi√£o branca indica onde deveriam ser concentrados os p√≥los de MF para alan√ßar os requisitos desejados.

      Obs.: S√≥ √© poss√≠vel acrescentar ("New") ou editar requisitos na √°rea branca do RL.

      

    * Informar **Requerimentos de projeto no gr√°fico de "*step*"**, na resposta no dom√≠nio tempo:

      ![Control_System_Designer-temporal_requirements](Control_System_Designer-temporal_requirements.png)

      Neste caso, foram informados os valores:

      ![Control_System_Designer-Design_Requirements_Temporal2](Control_System_Designer-Design_Requirements_Temporal2.png)





### Considera√ß√µes sobre PD e *Lead*

No nosso caso, vamos projetar (outro) PD ou um "*Lead*" (Controlador por Avan√ßo de Fase). Estes controladores seguem o seguinte tipo de equa√ß√£o:

$C_{PD}=K\left( s + z_{PD}\right)$

$C_{Lead}=K\left( \dfrac{s+z_{Lead}}{s+p_{Lead}}\right)$

Note que s√£o semelhantes. O *Lead* possui um p√≥lo extra em rela√ß√£o ao PD. Se forem tra√ßados esbo√ßos do RL mostrando como o mesmo se modifica conforme se adota uma diferente posi√ß√£o para seu p√≥lo em rela√ß√£o aos p√≥los e zeros da planta, vai ser percebido que geralmente os p√≥los de um *Lead* se distanciam (e bem) dos p√≥los mais r√°pidos da planta, com tend√™ncida √†: $p_{Lead} \to -\infty$. Considere que o p√≥lo de uma *tf* pode ser interpretada como um filtro passa-baixas. Ent√£o se o p√≥lo do *Lead* vier "antes" do p√≥lo mais r√°pido da planta, implica que este *Lead* estaria filtrando din√¢micas de alta frequ√™ncia da planta associadas com este p√≥lo mais r√°pido.



### Terminando o PD no App Control System Designer

**Considerando os projetos de PD¬¥s j√° realizados** na aulas passadas, vamos apostar na "**Op√ß√£o 2"** (ver [aula de 30/09/2024](aula_30092024.html)), na qual o zero do PD fica no intervalo: $-4 < z_{PD} < -1$, ou seja, entre os 2 p√≥los mais "lentos" (dominantes) da planta. 

Foi observado naquela aula, que provavelmente aproximar o zero do PD do p√≥lo em $s=-4$ √© que vai garantir um menor $t_s$, j√° que haver√° um p√≥lo de MF partindo do p√≥lo de MA da planta em $s=-1$, na dire√ß√£o deste zero (desejavelmente se afastando do eixo $j\omega$). Infelizmente, poder√° ser percebido que a medida que o zero do PD se aproxima do p√≥lo em $s-4$, ocorre um outro efeito (algo indesej√°vel): outros 2 p√≥los dominantes complexos partindo de $s=-4$ e $s=-10$, no tra√ßado do RL, assumem valores imagin√°rios ("sobem" no plano-s), com ponto de partida (*break-out*) pr√≥ximo de $-7$ (varia conforme a posi√ß√£o do zero do PD), mas ao inv√©s de simplesmente "subirem" o eixo $j\omega$, de forma paralela ao mesmo, antes disto, estes p√≥los de MF s√£o levemente atra√≠dos pelo zero, formando uma esp√©cie de um "**arco**". Esta distor√ß√£o √© causada pela presen√ßa pr√≥xima do zero do PD (que atrai estes outros p√≥los de MF). E poder√° ser percebido (com o aux√≠lio deste App), que quanto mais pr√≥ximo o zero do PD estiver do p√≥lo em $s=-4$, mais este "arco" se torce (indesejavelmente) para dire√ß√£o do eixo $j\omega$, implicando no aumento do valor do tempo de resposta, $t_s$. 

Note que o zero do PD aparece no RL deste App como um zero na **cor vermelha** (os p√≥los e zeros da planta v√£o aparecer na **cor azul**). Note que quando voc√™ coloca o mouse sobre o zero, o **cursor muda de seta para um "m√£o"**, indicando que sim, este zero pode ser movido (√© a id√©ia de projetar um controlador, voc√™ est√° selecionando uma posi√ß√£o adequada para o seu zero ou p√≥lo). Sugere-se que o estudante, modifique a posi√ß√£o deste zero, com a ajuda do mouse (clicar sobre o mesmo e manter o bot√£o do mouse pressionado) e voc√™ poder√° perceber facilmente como o "arco" se "abre" ou "fecha" e como o mesmo se afasta do eixo $j\omega$, conforme o zero do PD se aproxima ou afasta do p√≥lo em $s-4$. Note ainda que este App atualiza (quase em "*real-time*") o gr√°fico correspondente √° entrada degrau para este controlador considerando a nova posi√ß√£o do seu zero e ganho adotado (√©, acredito que at√© aqui voc√™ ainda n√£o tenha editado este valor). Ver:

![control_system_designer_zero](control_system_designer_zero.gif)

Note ainda que no RL mostrado por este App, os **polos de MF** aparecem com pequenos quadrados vermelhos, que surpresa (boa!), podem ser "arrastados" com o mouse, simulando o que voc√™ faria no CLI do Matlab usando a fun√ß√£o `rlocfind()`. Se voc√™ "subir" estes p√≥los de MF (aumentar valores da parte imagin√°ria) dos mesmos, implica que est√° aumentando o ganho do controlador. Observe na caixa de "Preview" do App, que se o bloco "C" (Controlador) estiver selacinado (na parte "Controllers and Fixed Parts"), voc√™ poder√° observar o valor do ganho de MF aumentando (ou dimunindo, depende para que lado voc√™ est√° "arrastando" os p√≥los de MF com o mouse). Voc√™ pode at√© mesmo editar √† m√£o, o valor do ganho, a posi√ß√£o do p√≥lo ou zero do controlador, dando um duplo clique sobre a op√ß√£o "C" (Controller) em "Controllers and Fixed Parts". Note que uma nova caixa de di√°logo se abre com caixas de texto que permitir√£o que voc√™ edite (digite) √† m√£o, valores desejados (par√¢metros) do controlador. Ver:

![control_system_designer_variando_ganho](control_system_designer_variando_ganho.gif)

Mas voltando ao caso do nosso PD, depois de "brincar" no App, variando a posi√ß√£o do zero do mesmo em fun√ß√£o do "arco" resultando no RL, e percebendo no gr√°fico de *step* caracter√≠sticas de resposta como o $t_s$, que existe uma rela√ß√£o "custo $\times$ bebef√≠cio" com a posi√ß√£o adotada para o zero do PD. Note ainda que intencionalmente se arrasta os p√≥los de MF para uma posi√ß√£o superior √† linha guia para certo $\zeta$ ou $\%OS$ (linha do "*sgrid*"), considerando que neste caso, trata-se de um sistema do tipo 0 (continua sendo este sistema mesmo com o acrescimo do PD) e por isto, sempre haver√° um erro de regime permanente ($e(\infty) \ne 0$) que pode ser reduzindo quando maior o ganho adotado para o controlador. Considere (lembre) que o Matlab ao mostrar "caracter√≠sticas de resposta" no gr√°fico da resposta ao degrau, calcula o $\%OS$ mas em rela√ß√£o ao $y(\infty)$ deste sistema. Se ele √© do tipo 0, significa que $y(\infty) \ne r(\infty)$ adotado para o sistema (isto √©, a sa√≠da n√£o vai convergir para o mesmo valor adotado para nossa refer√™ncia, no caso $r(\infty)=1$, porque foi usada uma entrada degrau unit√°rio). O Matlab calcula o $\%OS$ em rela√ß√£o √† $y(\infty)$ e n√£o em rela√ß√£o √† $r(\infty)$. Mas no gr√°fico da resposta ao degrau (ou mais simplesmente "*step*") podemos ver o valor de pico atingido pela resposta da planta no intante do pico do *overshoot*. Se √© estipulado que o *overshoot* m√°ximo √© de 10%, isto implica que $Max\{y(t)\}=1,1$ ($+10\%$ em rela√ß√£o √† $r(\infty)=1$). Ent√£o propositalmente se recomenda encontrar um valor de ganho em MF que fa√ßa o pico de resposta da planta, $y(t)$ alcan√ßar o m√°ximo valor permitido. Neste App √© f√°cil fazer isto, variando a posi√ß√£o dos p√≥los complexos de MF com ajuda do mouse e verificando a consequente resposta ao degrau para este novo valor de ganho.

Nesta se√ß√£o de trabalho, acabou se fixando a posi√ß√£o do zero do PD em $s=-2,5$ e o ganho do PD em $K=9,7$, o que pode se visto na pr√≥xima figura (tela final do App com controlador sintonizado): 

![projeto_PD2b](projeto_PD2b.jpg)

A *tf* final do controlador realizado com aux√≠lio deste App, pode ser exportada de volta para a ambiente de trabalho (ou CLI do Matlab), usando-se a op√ß√£o **Export** no barra de menu superior do App:

![Export_Model-Control_System_Designer.png](Export_Model-Control_System_Designer.png)

Note que neste caso (ver figura anterior), se deseja exportar apenas a *tf* do controlador, bloco "C" no App, e que o usu√°rio pode especificar um outro nome para a vari√°vel tipo *tf* que vai retratar a equa√ß√£o do controlador rec√©m projetado. Note que neste caso, optou-se por "**Export As**": `PD2b`. Uma vez editado estes dados, basta clicar no bot√£o "Export" e a nova vari√°vel *tf* `PD2b` deve aparecer na CLI do Matlab:

```matlab
>> who

Your variables are:

C_I               detal_x           ftmf_PI_ang       
G                 erro              limite            
K                 erro_Lag          numerador         
K2                erro_PD2          polosMF           
K3                erro_PD4          polos_MFd         
K_I               ftma_I            sigma             
K_Lag             ftma_Lag          sum_th_polos      
K_PD2             ftma_PD2          sum_th_polos_deg  
K_PD4             ftma_PD4          th1               
K_PI1             ftma_PD4aux       th1_deg           
K_PI3             ftma_PI1          th2               
K_PI5             ftma_PI3          th2_deg           
K_PI_ang          ftma_PI5          th3               
Kp                ftma_PI_ang       th3_deg           
Lag               ftmf              th4               
OS                ftmf2             th4_deg           
PD2               ftmf_I            th_zero           
PD2b              ftmf_I2           tout              
PD4               ftmf_K3           ts                
PI1               ftmf_Lag          wd                
PI3               ftmf_PD2          wn                
PI5               ftmf_PD4          zero_PI           
PI_ang            ftmf_PI1          zeta              
ans               ftmf_PI3          
delta_x           ftmf_PI5          

>> zpk(PD2)
 
  (s+2.5)
 
Continuous-time zero/pole/gain model.

>> zpk(PD2b)

 
  9.7 (s+2.5)
 
Name: C
Continuous-time zero/pole/gain model.
```


A se√ß√£o de trabalho no Control System Designer pode ser salva usando a op√ß√£o "**Save Session**". Um arquivo `*.mat` (de dados do Matlab) √© criado, mas n√£o seguindo a mesma estrutura interna dos arquivos `*.mat` criandos na CLI do Matlab. Por isto, recomenda-se adotar um nome que lembra √† que se refere este arquivo. Neste caso, foi criado o arquivo: [`PD2b_ControlSystemDesignerSession.mat`](PD2b_ControlSystemDesignerSession.mat).

Vamos finalizar esta aula, realizando o projeto de controlador do tipo *Lead* mas usando a abordafem de **contribui√ß√£o angular** usando um *script* inicialmente desenvolvido por NISE (mas atualizado), disponibilizado em:
% [Projeto de PD (Aula de 03/10/2019; Uso de Contribui√ß√£o angular)](https://fpassold.github.io/Controle_2/aula_PD_03out2019.html), o arquivo: [`find_polo_zero.m`](https://fpassold.github.io/Controle_2/find_polo_zero.m). 



## Projeto de Lead usando *script* `find_polo_zero`

O *script*: [`find_polo_zero.m`](https://fpassold.github.io/Controle_2/find_polo_zero.m)  foi melhorado √† partir de um semelhante apresentado por [Norman S. **Nise**](https://www.amazon.com.br/stores/Norman-S.-Nise/author/B001H6N2G0?ref=ap_rdr&isDramIntegrated=true&shoppingPortalEnabled=true) no livro ["Engenharia de Sistemas de Controle"](https://www.amazon.com.br/Engenharia-Sistemas-Controle-Norman-Nise-dp-8521638272/dp/8521638272/ref=dp_ob_title_bk). Serve para automatizar o c√°lculo das contribui√ßoes angulares resultantes dos p√≥los e zeros presentes na $FTMA(s)$ do controlador sendo projetado.

Pode ser usado o comando: `help find_polo_zero` para receber dicas de como usar o mesmo:

```matlab
>> help find_polo_zero
  <strong>find_polo_zero</strong>.m
  
  Angular contribution routine to find out where to locate pole or zero 
  of the controller depending on the desired location for MF poles
 
  Use:
  This routine already expects a tf named "ftma_aux"
    ftma_aux(s)=C(s)'*G(s);
  where: C(s)' is almost the full tf of the controller, 
         except for the pole or zero that this routine is expected to 
         determine using angular contribution.
  
  This routine uses angular contribution to find the position of the pole
  or the zero that is necessary to complete the tf of the controller.
  It asks almost at the end, whether the user wants to find out the 
  position of the pole or the zero that is missing.
 
  Fernando Passold, 14/10/2020, 20/10/2020, 30/10/2022, 30/11/2022.

>>
```

Supondo que queira projetar um *Lead*. Neste caso, temos 3 incognitas:

* Zero do Lead?
* P√≥lo do Lead?
* Ganho do Lead ‚Üê resolve-se usando o RL.

No caso do *Lead*, sabe-se que o p√≥lo do mesmo, normalmente √© mais r√°pido que o p√≥lo mais r√°pido da planta. Na maioria das vezes este p√≥lo fica em $s \to -\infty$ (distante, "isolado" dos outros p√≥los e zeros na $FTMA(s)$ do sistema).

Como neste caso, o p√≥lo mais r√°pido da planta est√° em $s=-10$, ser√° arbitrado a posi√ß√£o $s=-20$ para o mesmo. Esta defini√ß√£o se faz necess√°ria para reduzir o n√∫mero de inc√≥gnitas para este controlar. Assim, vamos usar este *script* para determinar o local do zero, inc√≥gnita faltante deste controlador.

```matlab
>> p_Lead=20;   % vari√°vel para o p√≥lo do Lead
>> C_aux=tf(1, [1 p_Lead])    % tf tempor√°ria do Lead enquanto seu zero √© desconhecido

C_aux =
 
    1
  ------
  s + 20
 
Continuous-time transfer function.

>> ftma_aux=C_aux*G;  % ftma auxiliar necess√°rio para o script
>> % Esta vari√°vel quase considera a eq. completa do controlador 
>> % na FTMA com excess√£o do seu zero. O script necessita a ftma_aux para ter
>> % acesso √† todos os zeros e p√≥los conhecidos da FTMA(s) com excess√£o do que falta
>> % determinar.
>> zpk(ftma_aux)      % verificando a ftma_aux

             20
  -------------------------
  (s+20) (s+10) (s+4) (s+1)
 
Continuous-time zero/pole/gain model.

>> find_polo_zero

Routine to determine the position of the pole or zero
that is missing to complete controller design

%OS$ (desired Overshoot, in %): ? 10
  ts_d (desired settling time): ? 0.7
Desired MF poles must be located at:
	s = -5.71429 ¬± j7.79644

Evaluating the pole(s) contribution angle(s):
  Pole 1) in s=-20 + j(0)	| angle: 28.62^o
  Pole 2) in s=-10 + j(0)	| angle: 61.20^o
  Pole 3) in s=-4 + j(0)	| angle: 102.40^o
  Pole 4) in s=-1 + j(0)	| angle: 121.16^o
			Sum(angle{poles}) = 313.39^o

Evaluating the zero(s) contribution angle(s):
			Sum(angle{zeros}) = 0.00^o

Determining pole or zero location of the controller:
Select: [p]=pole or [z]=zero, for the controller ? z

Angle contribution required for controller: 133.39^o
This means that the controller 
	ZERO must be at s = 1.65507

To finish the project, note that:

ftma =
 
        20 (s-1.655)
  -------------------------
  (s+20) (s+10) (s+4) (s+1)
 
Continuous-time zero/pole/gain model.

Find the controller gain with the command:

	>> K_ = rlocfind(ftma)

```

Note que quando se executou o *script*, foram ainda informados os seguintes dados (al√©m da vari√°vel `fama_aux`ter sido devidamente preparada):

* $\%OS$ m√°ximo desejado, neste caso: $\%OS=10\%$;
* $t_s$ (tempo de assentamento) desejado. Neste caso, foi inicialmente arbitrado o valor $t_s=0,7$ em fun√ß√£o dos resultados anteriores j√° obtidos com projetos de PD¬¥s.

Note que este *script* gera 2 gr√°ficos:

* **Gr√°fico da contribui√ß√£o angular final**, mostrando √¢ngulos calculados e usando linhas azuis para mostrar os p√≥los e zeros j√° conhecidos (estabelecidos) na `ftma_aux` e linhas vermelhas indicando onde deveria ficar localizado o zero do controlador para fazer com que o RL passe pelos p√≥los complexos que correspondem ao %*OS* e $t_s$ especificados. No caso:

    ![PD_contrib_angular_1.png](PD_contrib_angular_1.png)

* **Gr√°fico final do RL** obtido considerando o zero rec√©m calculado:

    <img src="RL_PD_contrib_angular_1.png" alt="RL_PD_contrib_angular_1" style="zoom:50%;" />

**Infelizmente** poder√° ser percebido que neste caso, obedecendo √† estes valores fornecidos, para o que RL passe efetivamente na posi√ß√£o desejada para os p√≥los complexos dominantes no RL, o zero deste PD resulta "inst√°vel", isto √©, **repare** que $z_{Lead}$ acabou ficando em $s=+1.65507$, na parte positiva direita do plano-s. 

Ocorre que o RL n√£o √© formado apenas pelo par de p√≥los complexos, mas existe um p√≥lo de MF real mais dominante at√© que os p√≥los complexos que justamente parte do p√≥lo em MA (da planta) em $s=-1$ que √© atra√≠do pelo zero do *Lead* em $s=+1,65507$, isto significa que, para at√© certo valor de ganho (enquanto o p√≥lo real dominante n√£o cruzar o eixo $j\omega$ em dire√ßao do plano-*s* positivo), ainda teremos uma resposta (em MF), est√°vel. Mas se este ganho superar este ponto (ponto do "***Ultimate Gain***"), o sistema passa a ser inst√°vel em MF. Raz√£o pela qual, este projeto ser√° simplesmente **abortado**. 

A figura anterior que mostra o RL final para o projeto deste *Lead*, permite observar, com a ajuda dos *Data Tips*, que: *Ultimate Gain*, $K_u \cong 25$, mas o ganho que deveria ser adotado para o RL passar sobre o par de p√≥los complexos desejados, √© $K \cong 50$, o que fatalmente vai implicar em p√≥lo real dominante na parte positiva do plano-*s* ou **instabilidade**.

O problema aqui √© que fomos muito "ganaciosos" ao estabelever o valor de $t_s \le 0,7$ segundos para este controlador com p√≥lo em $s=-20$.

### Tentativa #2 para projeto do *Lead* usando contribui√ß√£o angular

Sendo mais "conservador" na especifica√ß√£o do $t_s$ desejado para este controlador, vamos tentar o valor: $t_s \le 0,9$ segundos, e esperar que o novo zero calculando usando contribui√ß√£o angular, resulte na parte esquerda (parte real negativa) no plano-*s*.

```
>> find_polo_zero

Routine to determine the position of the pole or zero
that is missing to complete controller design

%OS$ (desired Overshoot, in %): ? 10
  ts_d (desired settling time): ? 0.9
Desired MF poles must be located at:
	s = -4.44444 ¬± j6.06389

Evaluating the pole(s) contribution angle(s):
  Pole 1) in s=-20 + j(0)	| angle: 21.30^o
  Pole 2) in s=-10 + j(0)	| angle: 47.51^o
  Pole 3) in s=-4 + j(0)	| angle: 94.19^o
  Pole 4) in s=-1 + j(0)	| angle: 119.60^o
			Sum(angle{poles}) = 282.59^o

Evaluating the zero(s) contribution angle(s):
			Sum(angle{zeros}) = 0.00^o

Determining pole or zero location of the controller:
Select: [p]=pole or [z]=zero, for the controller ? z

Angle contribution required for controller: 102.59^o
This means that the controller 
	ZERO must be at s = -3.08994

To finish the project, note that:

ftma =
 
         20 (s+3.09)
  -------------------------
  (s+20) (s+10) (s+4) (s+1)
 
Continuous-time zero/pole/gain model.

Find the controller gain with the command:

	>> K_ = rlocfind(ftma)
```

Desta vez, com estes dados, usando contribui√ß√£o angular, descobrimos que o zero deste controlador fica na parte real negativa do plano-*s*, levando a um p√≥lo real MF dominante tamb√©m na parte real negativa do plano-*s*, ou seja, teremos um sistema "est√°vel" em MF. 

Os seguintes gr√°ficos foram gerados:

<img src="Lead_contrib_angular_2.png" alt="Lead_contrib_angular_2.png" style="zoom: 50%;" />

<img src="RL_Lead_contrib_angular_2.png" alt="RL_Lead_contrib_angular_2" style="zoom: 50%;" />

O ganho do controlador foi definido aproveitando o RL j√° gerado pelo *script*:

```matlab
>> ftma_Lead=ftma;
>> K_Lead=rlocfind(ftma)
Select a point in the graphics window
selected_point =
      -4.4639 +     6.0242i
K_Lead =
        46.32
```

Fechando a malha com o valor de ganho encontrado:

```matlab
>> ftmf_Lead=feedback(K_Lead*ftma,1);
>> figure; step(ftmf_Lead, ftmf_PD2)
>> legend('Lead', 'PD2')
```

E finalmente obtemos a seguinte resposta ao degrau para este controlador (*Lead*) comparado com a resposta do PD projetado na aula anterior:

![step_Lead_contrib_angular_2.png](step_Lead_contrib_angular_2.png)

Percebemos que este *Lead* foi at√© mais r√°pido que o PD2, **mas** o erro de regime permanente do *Lead* √© maior que o encontrado para o PD projetado anteriormente:

```matlab
>> dcgain(ftmf_Lead)
ans =
      0.78157
>> dcgain(ftmf_PD2)
ans =
      0.84931
>> erro_Lead = ((1-dcgain(ftmf_Lead))/1)*100
erro_Lead =
       21.843
>> erro_PD2 = ((1-dcgain(ftmf_PD2))/1)*100
erro_PD2 =
       15.069
```

Lembrando que hav√≠amos especificado como requisitos de controle, $e(\infty) \le 10\%$, notamos que nenhum destes controladores permite atingir este objetivo. Mas estes controladores s√£o mais r√°pidos que o PI ou *Lag* j√° projetados na [aula de 16/09/2024](aula16092024.html). 

Motivo pelo qual, a √∫nica forma de tentar atingir os requisitos de controle especificados √© propondo controladores "mais completos", isto √©, que agregem ao mesmo tempo, a√ß√£o integral (para eliminar erro de regime permanente) e a√ß√£o derivativa (para acelerar a resposta do sistema). Temas que ser√£o contemplados nas pr√≥ximas aulas.

----

Salvando se√ß√£o de trabalho atual e encerrando atividades...

```matlab
>> save planta
>> diary off
>> quit
```

[üëãü•≥](https://youtu.be/g_w7GJBfiYc?si=iQm_TupRIpnqPso3)

----

<font size="2">üåä [Fernando Passold](https://fpassold.github.io/)[ üì¨ ](mailto:fpassold@gmail.com), <script language="JavaScript"><!-- Hide JavaScript...
var LastUpdated = document.lastModified;
document.writeln ("p√°gina criada em dd/mm/2024; atualizada em " + LastUpdated); // End Hiding -->
</script></font>

